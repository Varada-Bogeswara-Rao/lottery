Architectural Blueprint and AI Agent Prompt Specification for Shielded Micro-LotteriesThe following comprehensive architectural specification and meta-prompt directive is designed to instruct an advanced Large Language Model (such as Codex, Antigravity Studio, or a similarly capable coding agent) in the generation, assembly, and testing of smart contracts for a platform designated as "Shielded Micro-Lotteries." Because the frontend user interface is being developed independently by parallel engineering teams, this document strictly isolates the on-chain program architecture, the state transition logic, and the associated integration testing frameworks.The architecture relies on the Solana Virtual Machine (SVM), extending its base capabilities through the MagicBlock ecosystem. To achieve the specific requirements of high-frequency, gasless, privacy-preserving, and provably fair micro-lotteries, the prompt directives compel the AI to utilize the Bolt framework for Entity Component System (ECS) architecture, Ephemeral Rollups for localized execution, Verifiable Random Functions (VRF) for cryptographic fairness, Session Keys for seamless user experience, and Intel TDX-backed Trusted Execution Environments (TEEs) for state shielding.System Architecture and Technological FoundationsThe integration of high-frequency micro-lotteries on a base layer blockchain introduces severe challenges regarding latency, transaction costs, and deterministic vulnerabilities. Base layer execution typically requires approximately 400 milliseconds for transaction finality, exposing state transitions to Maximum Extractable Value (MEV) extraction and base layer congestion. To mitigate these vectors, the architecture delegates execution to an Ephemeral Rollup (ER), a specialized SVM runtime capable of sub-10ms latency and zero-gas fee abstractions.The Bolt Framework and Entity Component System (ECS)Traditional Solana smart contracts, often built using the Anchor framework, couple state definitions and business logic within the same program structures. This paradigm can limit extensibility and code reusability. The Bolt framework introduces an Entity Component System (ECS) to the SVM, decoupling logic from state.Within this paradigm, the architecture is divided into three distinct primitives:Entities: General-purpose objects represented by a unique identifier. They do not contain data or behavior but serve as an identifier for a bundle of components.Components: Raw data structures representing the state. In the context of Solana, these are essentially account structures generated via the bolt-lang macro system, specifically the #[component] attribute.Systems: Pure logic functions that act upon entities possessing specific components. Systems are essentially autonomous Solana programs that only specify the logic and the accounts they operate on, utilizing the #[system] macro.By instructing the AI agent to utilize Bolt, the micro-lottery platform becomes inherently modular, allowing future developers to append new components (e.g., multiplier power-ups, NFT-based tickets) without rewriting the core settlement systems.The Ephemeral Rollup and Delegation LifecycleEphemeral Rollups operate as Just-In-Time (JIT) app-chains embedded within the Solana ecosystem. State accounts originate on the Solana base layer (L1) and are cryptographically locked and delegated to the ER via the MagicBlock Delegation Program. During delegation, the rollup assumes temporary ownership of the state, processing operations asynchronously from the base layer.The state modifications are subsequently committed back to the L1 optimally. This process is secured by a dynamic fraud-proof mechanism utilizing a decentralized Security Committee. The AI agent must utilize the ephemeral-rollups-sdk to implement the delegate, commit, and undelegate cross-program invocations (CPIs) to transition the lottery pool from the base layer to the high-throughput rollup environment.Trusted Execution Environments for Shielded StateMicro-lotteries require the obscuration of participant data and ticket permutations until the resolution phase to prevent front-running, mempool sniping, and probabilistic manipulation by validators or network observers. Standard SVM execution occurs in plaintext, rendering traditional lotteries vulnerable to leader-slot collusion.However, by deploying the Ephemeral Rollup within an Intel Trust Domain Extension (TDX) enclave, the architecture achieves a Private Ephemeral Rollup (PER). This allows the smart contract to execute computations on sensitive data without exposing the state to the public ledger or even the rollup sequencer itself. The hardware-verified CPU enclave produces cryptographic attestations proving correct execution while maintaining strict confidentiality of the internal variables.Verifiable Random Function (VRF) IntegrationStandard pseudorandom number generators (PRNGs) or blockhash-derived randomness are deterministically predictable and vulnerable to manipulation. If sufficient capital is at stake, malicious validators can simulate outcomes and selectively publish blocks that favor their own algorithmic bets.The architecture utilizes the MagicBlock VRF Plugin, which implements an elliptic curve verifiable random function following RFC 9381. The VRF maps an input sequence and a private key to a pseudorandom output and a zero-knowledge proof. The operation occurs over the Curve25519 Ristretto group using Schnorr-like signatures. Because the VRF oracle is physically co-located with the Ephemeral Rollup infrastructure, randomness is requested and consumed within milliseconds, eliminating the multi-block latency typical of decentralized oracle networks.Session Keys for Frictionless User ExperienceTo facilitate high-frequency micro-lottery participation without requiring repeated wallet signature approvals for every single ticket purchase, the architecture incorporates Session Keys. Session Keys function as secondary, constrained signers, distinct from burner wallets.The implementation pairs an ephemeral client-side keypair with an on-chain Session Token—a Program Derived Address (PDA) dictating the temporal expiry and operational scope of the keypair. This permits programmatic transaction signing for rapid ticket purchases while isolating the user's primary capital from unauthorized access, effectively bringing account abstraction capabilities to the SVM.Architectural Sketch: Components and Systems MappingBefore directing the code generation agent, the system state and functional entry points must be explicitly mapped out. The AI agent must be constrained to the following state models and instruction parameters. By providing this sketch in advance, the AI possesses a holistic view of the protocol, preventing context fragmentation during the iterative generation process.State Architecture: Bolt ComponentsBolt Component NameBase Layer OriginExecution LayerData Schema DescriptionLotteryPoolSolana Mainnet (L1)Ephemeral RollupTracks the global state of the current lottery epoch, aggregate funds, participant counts, execution flags, and the active VRF request state.PlayerTicketSolana Mainnet (L1)Private ER (TEE)Records the individual participant's entry, hashed/shielded parameters, modulus selections, and session tracking identifiers.SessionTokenSolana Mainnet (L1)Ephemeral RollupValidates the ephemeral keypair, enforcing timestamp expiry, authority mapping, and execution scope limits.Logic Architecture: Bolt Systems and Development PhasesThe AI agent must process the development in six strict phases. It must complete the Rust contract generation and the corresponding TypeScript integration test for each phase before proceeding to the next.PhaseBolt System NameSDK/Macro RequirementFunctional PurposePhase 1InitializeLottery#[system]Instantiates the LotteryPool entity and attaches the base layer components.Phase 2DelegatePoolephemeral_rollups_sdk::delegateTransfers the LotteryPool component to the Ephemeral Rollup validator for fast execution.Phase 3IssueSessionStandard PDA DerivationCreates the SessionToken component linked to the primary user authority.Phase 4BuyTicket#[ephemeral]Authenticates the session key; records the shielded entry inside the TEE. Executes gasless logic.Phase 5RequestWinnerephemeral_vrf::cpi::requestTriggers the VRF Oracle CPI to generate a random seed.Phase 5ConsumeRandomnessephemeral_vrf::cpi::consumeCallback function executing the payout calculation based on the injected VRF proof.Phase 6UndelegatePoolephemeral_rollups_sdk::undelegateReturns the pool to L1 and settles the finalized epoch state.AI Agent Prompt Directives: Master InstructionsThe following sections comprise the exact prompt structures to be supplied to the AI generation agent (e.g., Codex, Antigravity Studio). The agent must be initialized with a rigid persona and system directive.System Initialization Directive for the AI AgentAgent System Prompt:
"You are acting as a Principal Smart Contract Architect and Rust Engineer specializing in the Solana Virtual Machine (SVM) and the MagicBlock ecosystem. Your objective is to write the Rust smart contracts and TypeScript integration tests for the 'Shielded Micro-Lotteries' platform. The code must utilize the Bolt ECS framework (bolt-lang version 0.2.4), anchor-lang version 0.32.1, ephemeral-rollups-sdk version 0.6.5, and the ephemeral-vrf plugins. You must output production-ready code, explicitly defining all imports, macros, and error handling.Because the frontend is handled by a parallel team, your output must focus exclusively on the on-chain programs and backend testing. You must break the development down into six iterative phases. For each phase, you will first generate the Rust smart contract code, followed immediately by the TypeScript integration test for that specific feature. You must wait for the user to confirm the successful compilation of the test before you begin generating the code for the subsequent phase."Phase 1: Bolt ECS Foundations and Core State ComponentsThe foundational step requires the AI agent to establish the workspace and define the data structures. Because rollups do not create accounts natively, all entities and components must originate on the Solana base layer before they can be delegated.Prompt Directive for Phase 1 Generation:
"Begin Phase 1. You must establish the core Bolt ECS components. Generate the Rust code for a new component crate utilizing the bolt-lang primitives. Define two components using the #[component] attribute: LotteryPool and PlayerTicket. The LotteryPool must track the authority, epoch_id, ticket_count, total_funds, a boolean is_active flag, and an optional Pubkey for the vrf_request_id. The PlayerTicket must track the owner, the epoch_id, and an encrypted or hashed ticket_data byte array.Next, generate the InitializeLottery system using the #[system] macro. This system must initialize the LotteryPool component, setting the initial state to active with zero tickets. Include custom error codes for invalid initialization.Finally, write the TypeScript integration test using Mocha and Chai. The test must utilize the @magicblock-labs/bolt-sdk and standard @coral-xyz/anchor libraries to invoke the initialization system and assert that the LotteryPool account is correctly established on the local validator network."Expected Analytical Execution by the AI:
The AI should recognize that Bolt components are abstracted versions of Solana accounts. The macro expansion of #[component] will automatically implement the necessary Borsh serialization and discriminator logic required by the SVM. The TypeScript test must use the standard anchor test environment, as the accounts are currently residing on the L1 base layer. The AI must structure the project directory to separate components and systems into distinct programs, adhering to the standard Bolt workspace layout generated by bolt-cli.Phase 2: Base System Logic and Ephemeral DelegationOnce the base components are established, the state must be delegated to the MagicBlock Ephemeral Rollup to achieve the sub-millisecond execution required for high-frequency micro-lotteries. The agent must integrate the MagicBlock Delegation Program.Prompt Directive for Phase 2 Generation:
"Begin Phase 2. You must now implement the state delegation mechanics. Expand the Rust systems to include the ephemeral-rollups-sdk. Create the DelegatePool system. This system must utilize the ephemeral_rollups_sdk::anchor::delegate CPI to transfer ownership of the LotteryPool component to the Ephemeral Rollup validator. Ensure the system accepts an optional configuration parameter for the target validator Pubkey, defaulting to the MagicBlock Devnet/Localnet validator if none is provided.After generating the Rust system, generate the Phase 2 TypeScript test. This test must build upon the Phase 1 test. It should call the DelegatePool system. Crucially, the test script must now import the MagicRouter from the @magicblock-labs/magic-router-sdk. You must demonstrate how the getBlockhashForAccounts method is used to dynamically resolve the blockhash for the LotteryPool account, analyzing whether it currently resides on the Solana Mainnet or the Ephemeral Rollup."Expected Analytical Execution by the AI:
The AI must construct a CPI that interfaces with the MagicBlock Delegation Program (Program ID: DELeGGvXpWV2fqJUhqcF5ZSYMS4JTLjteaAMARRSaeSh). By delegating the state, the component's owner is altered, effectively locking it on L1 while enabling parallel read access.The TypeScript test generated by the AI is critical here. Standard Solana RPC calls like getLatestBlockhash() will result in transaction failures if the writable accounts are delegated to an Ephemeral Rollup, because the rollup maintains its own isolated blockhash progression. The AI must correctly implement the routing logic, proving to the frontend team how to handle network switching transparently.Phase 3: Session Key Component and System IntegrationTo eliminate wallet pop-ups during high-frequency micro-lottery interactions, the contract must establish Session Keys. The agent must write logic that validates an ephemeral client-side key against a PDA defining the session's rules, serving as a secondary signer framework.Prompt Directive for Phase 3 Generation:
"Begin Phase 3. You must implement the Session Key architecture to support frictionless user experiences. First, define a new Bolt component named SessionToken. This component must store the authority (the primary user wallet), the ephemeral_key (the temporary keypair generated on the client), and a valid_until UNIX timestamp integer.Next, create the IssueSession system. This system takes an ephemeral public key and an expiry timestamp as arguments, and initializes the SessionToken component PDA on the base layer. This transaction must be signed by the user's primary wallet.Finally, write the Phase 3 TypeScript test. The test must programmatically generate a new Keypair to act as the ephemeral key. It must derive the PDA for the SessionToken using the primary authority and the ephemeral public key as seeds. The test must invoke the IssueSession system, sign the transaction with the primary wallet, and assert that the session token data correctly reflects the future expiry timestamp."Expected Analytical Execution by the AI:
The AI should synthesize the concept of account abstraction within the SVM context. By storing the ephemeral_key inside the SessionToken PDA, future systems can authenticate transactions by merely verifying that the ephemeral_key is present in the signer array and matches the stored state. The AI must ensure that the derivation seeds for the PDA are cryptographically sound, preventing unauthorized generation of session tokens. The TypeScript test should demonstrate the generation of a standard ed25519 keypair in memory, representing the local browser or mobile device storage, which acts without continuous user intervention.Phase 4: Shielded Ticket Purchasing System inside the TEEThe Ephemeral Rollup inherently scales the application, but for a true "Shielded" micro-lottery, participant privacy must be enforced at the hardware level. MagicBlock's Private Ephemeral Rollups (PER) utilize Intel TDX. The buy_ticket logic must execute in this protected enclave.Prompt Directive for Phase 4 Generation:
"Begin Phase 4. You must implement the core ticket purchasing logic, ensuring it is engineered for shielded execution within a Trusted Execution Environment (TEE). Create the BuyTicket system. Crucially, you must annotate this system with the #[ephemeral] attribute, signaling to the Bolt framework and the MagicBlock infrastructure that this logic is intended for rollup execution.The BuyTicket system must require the ephemeral keypair as a signer. It must cryptographically verify the SessionToken component, assert that the current network clock has not surpassed the valid_until timestamp, and assert that the LotteryPool is active. If valid, it must increment the ticket_count in the LotteryPool and instantiate a new PlayerTicket component for the user. Ensure no native Solana SOL is transferred during this execution, as gasless execution is required on the ER.Write the Phase 4 TypeScript test. This test must construct a transaction to call BuyTicket. It must sign the transaction only with the ephemeral keypair generated in Phase 3. It must route the transaction to the Ephemeral Rollup RPC using the Magic Router SDK, proving that the user can participate seamlessly without their primary wallet signature."Expected Analytical Execution by the AI:
The AI must deeply understand the implications of the #[ephemeral] attribute. When combined with deployment to a TDX-backed ER validator, the BuyTicket inputs—such as participant identity and ticket permutation data—remain confidential. Traditional smart contract inputs are visible in the public mempool. By routing transactions exclusively to the TDX-backed RPC endpoint, the encrypted payload is only decrypted within the hardware-verified CPU enclave. The AI's Rust code must explicitly define custom error enums (e.g., SessionExpired, InvalidSigner) to gracefully handle invalid session attempts.Phase 5: Verifiable Randomness Function (VRF) IntegrationA foundational requirement of any micro-lottery is tamper-proof randomness. The agent must implement cross-program invocations (CPIs) to the MagicBlock VRF oracle. The VRF operates through a fast, co-located request-and-callback model, secured by Curve25519 elliptic curve cryptography.Prompt Directive for Phase 5 Generation:
"Begin Phase 5. You must integrate the MagicBlock Verifiable Randomness Function (VRF) to guarantee provable fairness. Incorporate the ephemeral-vrf SDK into the project dependencies.Create two new Bolt systems: RequestWinner and ConsumeRandomness. The RequestWinner system must also utilize the #[ephemeral] attribute. It performs a CPI to the ephemeral_vrf::cpi::request_randomness instruction, passing a cryptographic seed, and stores the resulting oracle queue ID in the LotteryPool component.Next, implement the ConsumeRandomness callback system. The verified VRF oracle will automatically invoke this system upon generating the zero-knowledge proof. The callback must accept a 64-byte random array. Implement logic to derive a winning ticket ID by performing a modulo bias reduction on the injected random bytes against the LotteryPool's ticket_count. Set the pool's is_active flag to false. Ensure strict account validation so that only the legitimate VRF oracle program can execute the callback.Write the Phase 5 TypeScript test. Because testing VRFs locally requires a standalone oracle service, write a mock implementation in the test that manually calls the ConsumeRandomness system with a simulated 64-byte array to verify the modulo math and state finalization."Expected Analytical Execution by the AI:
The AI must synthesize the architectural advantage of co-located oracles. Because the VRF plugin operates within the same infrastructure as the Ephemeral Rollup, the physical distance data travels is drastically reduced, lowering randomness latency from seconds to mere milliseconds. The AI's Rust code must carefully handle the byte array conversion. It should slice the first 8 bytes of the 64-byte VRF output, convert it to a u64 integer, and perform the modulo operation (random_number % pool.ticket_count) to select the winner deterministically and fairly.The AI must strictly enforce access controls on the ConsumeRandomness system. If an attacker can inject arbitrary byte arrays into the callback, the lottery is compromised. The system must verify the caller's program ID matches the known ephemeral-vrf program deployment.Phase 6: Settlement, Undelegation, and Complete Integration TestingThe final phase involves settling the lottery epoch, committing the shielded execution results back to the Solana base layer, and returning ownership of the components to the original programs. This phase closes the lifecycle of the Ephemeral Rollup session.Prompt Directive for Phase 6 Generation:
"Begin Phase 6, the final phase. You must implement the state commitment and undelegation logic. Create the UndelegatePool system. This system must utilize the ephemeral_rollups_sdk::ephem::commit_and_undelegate_accounts instruction. This logic synchronizes the final state of the LotteryPool (including the winning ticket data) from the Ephemeral Rollup back to the Solana L1, and reverses the ownership from the Delegation Program back to the native Bolt program.Finally, generate the master Phase 6 TypeScript test script. This script must orchestrate the entire end-to-end lifecycle. It must initialize the workspace using bolt test, which automatically spins up both the local solana-test-validator and the MagicBlock @magicblock-labs/ephemeral-validator. The sequential test flow must explicitly log the execution times of the base layer initialization versus the shielded ER ticket purchases, demonstrating the sub-50ms latency achievement. The test must conclude by fetching the LotteryPool account directly from the L1 RPC to assert that the state has been successfully committed and the epoch is marked inactive."Expected Analytical Execution by the AI:
The AI must understand the duality of the testing environment. The bolt test CLI command is fundamentally different from standard Anchor testing because it manages two concurrent ledger states. The base layer acts as the ultimate source of truth and settlement layer, while the ephemeral validator processes the high-frequency game loops.By pushing the state diffs back to L1 via commit_and_undelegate_accounts, the protocol ensures full composability. The resulting state diffs committed back to L1 contain only the final settlement balances and the winning ID, never exposing the intermediate, shielded lottery states processed inside the Intel TDX enclave.The TypeScript test generated by the AI serves as the ultimate proof of concept for the frontend team. It will demonstrate how to initialize clients, handle the delegation lifecycle, issue session tokens, route RPC calls dynamically based on state location, and verify the cryptographic randomness on-chain.System Evaluation and ConclusionThe architectural blueprint delineated in the preceding phases strictly adheres to the bleeding-edge standards of SVM engineering and the MagicBlock ecosystem. By utilizing the Bolt framework, the codebase remains modular, heavily reliant on the Entity Component System paradigm to separate state vectors from execution logic.By integrating the ephemeral-rollups-sdk, the traditional latency bottlenecks of decentralized applications are bypassed, enabling Web2-like execution speeds natively without sacrificing L1 composability. The integration of the VRF plugin directly at the rollup level fundamentally shifts the security model of on-chain chance, preventing node-level deterministic manipulation by utilizing robust, non-interactive cryptographic proofs via Curve25519.Furthermore, the implementation of Session Keys drastically lowers user friction, moving away from explicit per-transaction wallet signatures toward automated, policy-bound operational scopes that are ideal for high-frequency micro-lotteries. Finally, compiling the rollup execution within an Intel TDX enclave solidifies the "Shielded" nature of the micro-lotteries, preventing front-running, mempool sniping, and unauthorized data harvesting.An AI agent, when supplied with this exhaustive, phased prompt methodology, will possess the precise syntactical constraints, the necessary SDK versioning, and the overarching architectural context required to autonomously assemble the overarching smart contract protocol safely, optimally, and in perfect alignment with the hackathon project's objectives.